# SNMP 카운터의 롤오버
- SNMP 카운터(ifHCInOctets, ifHCOutOctets)는 64비트 정수로 동작하며, 최대값(2^64-1)을 초과하면 0으로 롤오버된다.
- 롤오버가 발생하면 non_negative_derivative 계산이 잘못된 값을 반환할 수 있다.
- 데이터에서 시간별 증가량(Last Out, Last In)과 Sum을 비교하여 불연속점이 있는지 확인해야 한다.

# 롤오버(Rollover)란?
- 롤오버는 컴퓨터 시스템에서 숫자 카운터가 최대값에 도달한 후 다시 초기값(일반적으로 0)으로 돌아가는 현상을 의미한다.
- 예: SNMP 카운터에서의 롤오버

## 네트워크 장비는 데이터 전송량(예: ifHCInOctets, ifHCOutOctets)을 추적하기 위해 32비트 또는 64비트 카운터를 사용합니다.
- 이 카운터는 지속적으로 증가하지만, 숫자가 해당 비트의 최대값(32비트: 4,294,967,295, 64비트: 18,446,744,073,709,551,615)을 넘어서면 다시 0으로 초기화된다.
- 이 현상을 롤오버라고 부른다.

## 롤오버가 데이터에 미치는 영향
예를 들어, 64비트 카운터가 다음과 같이 기록되었다고 가정한다.

```
시간       카운터 값
08:44     18,446,744,073,709,551,600
08:48     10
```

카운터가 최대값에 도달한 후 다시 0으로 초기화된 것이므로, 실제로 증가하는 증가량

```
증가량 = (최대값 - 이전값) + 현재값
      = (18,446,744,073,709,551,615 - 18,446,744,073,709,551,600) + 10
      = 25
```

하지만, 이를 고려하지 않으면 비정상적으로 큰 감소값으로 계산될 수 있다.

## Derivative 계산 오류
- InfluxDB의 non_negative_derivative는 이전 값이 현재 값보다 클 경우 증가량을 음수로 판단해 버립니다. 이를 보정하지 않으면 잘못된 결과가 나타날 수 있다.

## 롤오버 감지 방법
### 데이터 값의 감소 확인
- 롤오버는 값이 최대값에서 0으로 초기화되므로, 데이터가 갑자기 감소한 경우 이를 확인할 수 있다.

## 데이터 값의 비정상적 점프
- 롤오버 전후의 값이 비정상적으로 증가하거나 감소한 경우가 감지 포인트

## 롤오버 해결 방법
- 데이터 전처리
- 데이터가 롤오버되었는지 확인한 후, 최대값을 기준으로 계산하여 올바른 증가량을 구한다.

```
if 현재값 < 이전값:
    증가량 = (최대값 - 이전값) + 현재값
else:
    증가량 = 현재값 - 이전값
```

## InfluxDB 쿼리 조정
- non_negative_derivative 대신 롤오버를 고려한 커스텀 계산 방식을 적용하거나, 이를 보정하는 플러그인을 사용한다.

## 실제 사례
- 네트워크 장비에서 64비트 카운터를 사용하는 경우에도, 짧은 시간 간격에 대량 트래픽이 발생하면 롤오버가 발생할 수 있다. 

### 이를 예방하기 위해
- 데이터를 수집하는 간격을 조정
- 장비의 카운터 크기를 확인하여 최대값을 넘지 않도록 관리해야 한다.